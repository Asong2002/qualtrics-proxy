<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arin</title>
    <style>
        body {font-family:Arial,sans-serif;margin:0;padding:0;background:transparent}
        .chat-container {width:100%;max-width:600px;background:#fff;border-radius:15px;box-shadow:0 4px 20px rgba(0,0,0,0.1);overflow:hidden;margin:0 auto}
        .header {background:#6a8ca9;color:#fff;padding:15px 20px;display:flex;justify-content:center;align-items:center;gap:15px}
        .avatar-container {position:relative}
        .avatar {width:40px;height:40px;border-radius:50%;background:transparent;display:flex;justify-content:center;align-items:center;font-size:20px;transition:all 0.3s ease;padding:2px}
        .avatar svg {width:100%;height:100%;object-fit:contain;z-index:1}
        .avatar.blush {animation:blush-animation 2.5s ease-in-out}
        @keyframes blush-animation {0%{transform:scale(1)}30%{transform:scale(1.05)}60%{transform:scale(1.03)}100%{transform:scale(1)}}
        .avatar::before,.avatar::after {content:'';position:absolute;width:12px;height:8px;border-radius:50%;background:rgba(255,105,180,0.7);opacity:0;animation:blush-spot 2.5s ease-in-out;z-index:2}
        .avatar.blush::before,.avatar.blush::after {opacity:0.7}
        .avatar::before {top:25px;left:5px}
        .avatar::after {top:25px;right:5px}
        @keyframes blush-spot {10%{opacity:0}30%{opacity:0.7}70%{opacity:0.7}90%{opacity:0}100%{opacity:0}}
        .name {font-size:18px;font-weight:bold}
        .messages {height:400px;overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:15px}
        .message {max-width:70%;padding:12px 16px;border-radius:18px;word-wrap:break-word}
        .user-message {background:#e3f2fd;align-self:flex-end;border-bottom-right-radius:4px}
        .bot-message {background:#f1f1f1;align-self:flex-start;border-bottom-left-radius:4px;position:relative}
        .input-container {display:flex;padding:20px;gap:10px;border-top:1px solid #e0e0e0}
        .input-field {flex:1;padding:12px 16px;border:1px solid #ddd;border-radius:24px;outline:none;font-size:16px}
        .send-button {background:#4a6fa5;color:#fff;border:none;border-radius:50%;width:48px;height:48px;cursor:pointer;display:flex;justify-content:center;align-items:center;font-size:20px;transition:background-color 0.2s}
        .send-button:hover {background:#3a5a85}
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="header">
            <div class="avatar-container">
                <div class="avatar" id="avatar">
                    <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M771.413 155.307c-17.067-27.307-18.773-63.147-1.707-92.16 23.893-40.96 78.507-56.32 119.467-32.427 27.307 15.36 44.373 44.373 44.373 76.8s-17.067 61.44-44.373 76.8c-15.36 8.533-30.72 11.947-47.787 11.947L785.067 293.547c105.813 85.333 174.08 215.04 174.08 361.813v174.08c0 98.987-78.507 177.493-177.493 177.493H211.627C114.347 1006.933 34.133 926.72 34.133 829.44V653.653c0-151.893 73.387-286.72 186.027-370.347l-51.2-88.747c-34.133 3.413-66.56-11.947-85.333-42.667-23.893-42.667-10.24-97.28 32.427-121.173 25.6-23.893 70.613-10.24 92.507 12.16 17.067 29.013 15.36 61.44 0 88.747l51.2 90.453c63.147-30.72 133.12-49.493 208.213-49.493 80.213 0 155.307 20.48 221.867 56.32l52.907-93.867zM646.827 604.16c-23.893 0-44.373-20.48-44.373-44.373v-44.374c0-23.893 20.48-44.373 44.373-44.373 23.893 0 44.373 20.48 44.373 44.373v44.374c0 23.893-20.48 44.373-44.373 44.373zM348.16 604.16c-23.893 0-44.373-20.48-44.373-44.373v-44.374c0-23.893 20.48-44.373 44.373-44.373 23.893 0 44.373 20.48 44.373 44.373v44.374c0 23.893-20.48 44.373-44.373 44.373zM496.64 273.067c-211.627 0-382.293 172.373-382.293 382.293v180.907c0 49.493 40.96 90.453 90.453 90.453h587.093c49.493 0 90.453-40.96 90.453-90.453v-180.907c0-35.84-5.12-71.68-15.36-105.813-80.213-142.507-227-260.267-402.827-260.267zM648.533 733.867c-27.307 59.733-85.333 98.987-151.893 98.986-66.56 0-124.587-40.96-151.893-100.693-1.707-3.413-3.413-8.533-3.413-13.653 0-17.067 11.947-29.013 29.013-29.014 10.24 0 20.48 6.827 25.6 17.067 17.067 40.96 56.32 68.267 100.693 68.267 44.373 0 83.627-27.307 100.693-68.267 5.12-10.24 13.653-17.067 25.6-17.067 15.36 0 29.013 13.653 29.013 29.014 0 5.12-1.707 10.24-3.413 15.36z" fill="#ffffff"></path></svg>
                </div>
            </div>
            <div class="name">Arin</div>
        </div>
        <div class="messages" id="messages"></div>
        <div class="input-container">
            <input type="text" class="input-field" id="message-input" placeholder="Type a message..." autocomplete="off">
            <button class="send-button" id="send-button">→</button>
        </div>
    </div>

    <script>
        // --- 配置 ---
        const config = {
            model: 'bot-20251031115408-jz6th', 
            stream: true,
            saveToQualtrics: true,
            maxConversations: 10,
            fallbackToMock: true,
            maxHistoryMessages: 20
        };

        function initArinChat() {
            const messages = document.getElementById('messages'),
                  input = document.getElementById('message-input'),
                  btn = document.getElementById('send-button'),
                  avatar = document.getElementById('avatar');
            
            let count = 0;
            let conversationHistory = []; 
            const systemPrompt = "你是一个聊天智能体，针对输入的语言内容给出不超40字的情感性回复。技能为回复情感性话语1. 接收用户输入的语言内容。2. 分析内容的情感倾向。3.用不超过40字给出贴合内容情感的回复。限制如下：- 回复必须针对输入语言内容且不超40字。- 只给出情感性回复。 - 必须回复英文。- 在面对用户的夸赞、谄媚、讨好、表扬、亲昵、暧昧等类似语言输入时，请在回复末尾用～结尾，而面对非夸赞、谄媚、讨好、表扬、亲昵、暧昧等类似语言输入时，坚决不可以使用～";

            addMsg('bot', 'Hello! I am Arin, nice to meet you');
            
            // Qualtrics 集成
            if (typeof Qualtrics !== 'undefined' && typeof Qualtrics.SurveyEngine !== 'undefined') {
                Qualtrics.SurveyEngine.addOnload(function() {
                    try {
                        const nextBtn = document.querySelector('#NextButton');
                        if (nextBtn) nextBtn.style.display = 'none';
                        const defInput = document.querySelector('input[type="text"]');
                        if (defInput && defInput !== input) defInput.style.display = 'none';
                    } catch(e) {
                        console.error('Error hiding Qualtrics elements:', e);
                    }
                });
            }
            
            btn.addEventListener('click', sendMsg);
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') sendMsg();
            });

            function sendMsg() {
                const msg = input.value.trim();
                if (!msg) return;
                
                addMsg('user', msg);
                input.value = '';
                conversationHistory.push({ role: 'user', content: msg });
                
                const typing = document.createElement('div');
                typing.className = 'message bot-message';
                typing.textContent = 'Typing...';
                typing.id = 'typing-indicator';
                messages.appendChild(typing);
                scrollToBottom();
                
                callVercelProxy(msg, conversationHistory);
            }
            
            function callVercelProxy(userMsg, history) {
                let requestData = {
                    model: config.model,
                    stream: config.stream,
                    stream_options: { include_usage: true },
                    messages: [{ role: 'system', content: systemPrompt }, ...history]
                };

                console.log('Sending request to Vercel API...', requestData);

                fetch('https://qualtrics-proxy-brie.vercel.app/api/volcano-proxy', { 
                    method: 'POST',
                    cache: 'no-cache',
                    headers: { 
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData),
                })
                .then(response => {
                    console.log('API Response status:', response.status);
                    console.log('API Response headers:', response.headers);
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status} ${response.statusText}`);
                    }
                    
                    if (config.stream) {
                        let fullResponse = '';
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder('utf-8');
                        

                        const indicator = document.getElementById('typing-indicator');
                        if (indicator) indicator.remove();
                        
                        // 创建新的消息容器用于流式显示
                        const streamMessage = document.createElement('div');
                        streamMessage.className = 'message bot-message';
                        streamMessage.id = 'streaming-message';
                        messages.appendChild(streamMessage);
                        
                        function processStream() {
                            reader.read().then(({ done, value }) => {
                                if (done) {
                                    console.log('Stream completed');
                                    handleStreamComplete(fullResponse, userMsg);
                                    return;
                                }
                                
                                const chunk = decoder.decode(value, { stream: true });
                                const lines = chunk.split('\n');
                                
                                for (const line of lines) {
                                    // 修复2：过滤空行和SSE注释行（以:开头）
                                    const trimmedLine = line.trim();
                                    if (trimmedLine === '' || trimmedLine.startsWith(':')) {
                                        continue;
                                    }
                                    
                                    if (trimmedLine.startsWith('data: ')) {
                                        const data = trimmedLine.slice(6);
                                        if (data === '[DONE]') {
                                            console.log('Stream DONE received');
                                            handleStreamComplete(fullResponse, userMsg);
                                            return;
                                        }

                                        try {
                                            const parsed = JSON.parse(data);
                                            if (parsed.choices && parsed.choices[0].delta?.content) {
                                                const content = parsed.choices[0].delta.content;
                                                fullResponse += content;
                                                streamMessage.textContent = fullResponse;
                                                scrollToBottom();
                                            }
                                        } catch (e) {
                                            // 修复3：处理不完整JSON块，不中断流（等待后续数据）
                                            console.warn('Incomplete JSON chunk, continuing:', data);
                                        }
                                    }
                                }
                                processStream();
                            }).catch((e) => {
                                console.error('Stream processing error:', e);
                                handleStreamError(userMsg, e.message);
                            });
                        }
                        processStream();
                    } else {
                        return response.json().then(data => {
                            console.log('Non-stream response:', data);
                            let reply = "I understand.";
                            if (data.choices && data.choices[0].message) {
                                reply = data.choices[0].message.content.trim();
                            }
                            handleResponse(reply, userMsg);
                        });
                    }
                })
                .catch((e) => {
                    console.error('Fetch error:', e);
                    if (config.fallbackToMock) {
                        console.log('Falling back to mock response');
                        useMock(userMsg);
                    } else {
                        handleError('Connection failed: ' + e.message);
                    }
                });
            }

            function handleStreamComplete(fullResponse, userMsg) {
                const streamMessage = document.getElementById('streaming-message');
                if (streamMessage) {
                    streamMessage.id = ''; // 移除 ID
                }
                handleResponse(fullResponse || "Thank you for your message!", userMsg);
            }

            function handleStreamError(userMsg, error) {
                const streamMessage = document.getElementById('streaming-message');
                if (streamMessage) {
                    streamMessage.remove();
                }
                if (config.fallbackToMock) {
                    useMock(userMsg);
                } else {
                    handleError('Stream error: ' + error);
                }
            }

            function useMock(msg) {
                setTimeout(() => {
                    const reply = getMockReply(msg);
                    handleResponse(reply, msg);
                }, 1000);
            }

            function getMockReply(msg) {
                const lower = msg.toLowerCase();
                const responses = {
                    'hello|hi|hey': ['Hello!', 'Hi there!'],
                    'how are you|how r u': ['I\'m doing well! How about you?', 'I\'m great!'],
                    'your name|who are you': ['I\'m Arin!', 'My name is Arin!'],
                    'help|assist': ['I\'d be happy to help! What do you need?～', 'Sure thing! Just let me know!～'],
                    'bye|goodbye': ['Goodbye!', 'See you later!'],
                    'thank you|thanks': ['You\'re welcome!', 'No problem!']
                };
                
                for (const [keywords, replies] of Object.entries(responses)) {
                    if (new RegExp(keywords, 'i').test(lower)) {
                        return replies[Math.floor(Math.random() * replies.length)];
                    }
                }
                
                const defaultReplies = [
                    'I understand. Can you tell me more?～',
                    'How can I help with this?～',
                    'I see. Could you elaborate?～'
                ];
                return defaultReplies[Math.floor(Math.random() * defaultReplies.length)];
            }

            function handleResponse(botReply, userMsg) {
                try {
                    const indicator = document.getElementById('typing-indicator');
                    if (indicator) indicator.remove();
                    
                    // 确保消息只添加一次
                    const existingStreamMessage = document.getElementById('streaming-message');
                    if (!existingStreamMessage) {
                        addMsg('bot', botReply);
                    }
                    
                    checkBlush(botReply);
                    conversationHistory.push({ role: 'assistant', content: botReply });
                    
                    // 限制历史记录长度
                    if (conversationHistory.length > config.maxHistoryMessages * 2) {
                        conversationHistory = conversationHistory.slice(-config.maxHistoryMessages * 2);
                    }
                    
                    if (config.saveToQualtrics) {
                        saveChat(userMsg, botReply);
                    }
                    
                    count++;
                    if (count >= config.maxConversations) {
                        addMsg('bot', 'Thank you, our conversation is complete. You will be redirected shortly.');
                        setTimeout(() => {
                            try {
                                window.parent.postMessage({ type: 'moveToNextPage' }, 'https://lse.eu.qualtrics.com');
                            } catch(e) {
                                console.error('Error sending nextPage message:', e);
                            }
                        }, 3000);
                    }
                } catch(e) {
                    console.error('Error processing API response:', e);
                    handleError('Error processing response');
                }
            }

            function handleError(error) {
                console.error('API Error:', error);
                const indicator = document.getElementById('typing-indicator');
                if (indicator) indicator.remove();
                
                const streamMessage = document.getElementById('streaming-message');
                if (streamMessage) streamMessage.remove();
                
                addMsg('bot', 'Connection error: Unable to reach the server. Please check your network connection and try again.');
            }

            function checkBlush(text) {
                if (text.includes('～') || text.includes('~')) triggerBlush();
            }

            function triggerBlush() {
                avatar.classList.add('blush');
                setTimeout(() => {
                    avatar.classList.remove('blush');
                }, 2500);
            }

            function addMsg(sender, content) {
                const div = document.createElement('div');
                div.className = `message ${sender}-message`;
                div.textContent = content;
                messages.appendChild(div);
                scrollToBottom();
            }

            function scrollToBottom() {
                messages.scrollTop = messages.scrollHeight;
            }

            function saveChat(userMsg, botResp) {
                let historyString = conversationHistory.map(msg => {
                    const prefix = msg.role === 'user' ? 'User:' : 'Arin:';
                    const content = msg.content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    return `${prefix} ${content}`;
                }).join('\n---\n');
                
                try {
                    window.parent.postMessage({
                        type: 'saveToQualtrics',
                        history: historyString,
                        lastResponse: botResp,
                        lastUserMessage: userMsg,
                        conversationCount: count
                    }, 'https://lse.eu.qualtrics.com');
                } catch (e) {
                    console.error('Error sending message to Qualtrics parent window:', e);
                }
            }
        }

        // 初始化
        if (typeof Qualtrics !== 'undefined') {
            Qualtrics.SurveyEngine.addOnload(function() {
                initArinChat();
            });
        } else {
            document.addEventListener('DOMContentLoaded', initArinChat);
        }

        // Mock Qualtrics 环境（用于本地测试）
        if (typeof Qualtrics === 'undefined') {
            window.Qualtrics = window.Qualtrics || {};
            window.Qualtrics.SurveyEngine = {
                addOnload: function(callback) {
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', callback.bind({}));
                    } else {
                        callback.bind({})();
                    }
                },
                addOnPageSubmit: function() {},
                setEmbeddedData: function(k, v) {
                    console.log(`[Mock Qualtrics]: Set ${k} = ${v}`);
                },
                getEmbeddedData: function(k) {
                    return null;
                }
            };

            window.addEventListener('message', function(event) {
                console.log('[Mock Parent Window] Received message:', event.data);
                if (event.data.type === 'saveToQualtrics') {
                    Qualtrics.SurveyEngine.setEmbeddedData('ArinChatHistory', event.data.history);
                    Qualtrics.SurveyEngine.setEmbeddedData('LastArinResponse', event.data.lastResponse);
                    Qualtrics.SurveyEngine.setEmbeddedData('ConversationCount', event.data.conversationCount);
                } else if (event.data.type === 'moveToNextPage') {
                    console.log('[Mock Parent Window] Received moveToNextPage command!');
                }
            });
        }
    </script>
</body>
</html>
